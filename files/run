#!/bin/sh

# does named pipe name exist but not a named pipe?
# create named pipe, if it doesn't already
# trap signals
# start server, listening to named pipe for commands
# poll for signals

# does server.jar exist as a symlink?

# failure modes: log, touch down, and svc -d
# If we merely log, when the problem is fixed the server will
# automatically start. This is a more reasonable behaivor.

# env Xms Xmx

exec 2>&1

pipe='commands'
jar='server.jar'

abort() {
    printf 'E: %s\n' "$@"
    touch down
    svc -d .
    exit 1
}

if [ -e "$pipe" -a  ! -p "$pipe" ]; then
    rm -f "$pipe" || abort "$pipe exists, and is not a named pipe"
fi

if [ ! -e "$pipe" ]; then
    mkfifo "$pipe" || abort "Cannot create $pipe"
fi

if [ ! -e "$jar" -o ! -h "$jar" ]; then
    abort "$jar is not a symlink to the appropriate minecraft server jarfile"
fi


# svc uses the following signals:
# -p STOP; -c CONT; -h HUP; -a ALRM; -i INT; -t TERM; -k KILL

# STOP/CONT are pretty useless for a server - will cause Can't keep up! warnings
# HUP and ALRM can be used to force a save of the world
# INT and TERM can be used to force a shutdown
# KILL, well, we can't do much about that, now, can we?

save() {
    printf 'save-all\n' > "$pipe"
}

stop() {
    printf 'stop\n' > "$pipe"
    wait $serverpid
    kill -kill $$
}

sig_hup() {
    save
}

sig_alrm() {
    save
}

sig_int() {
    stop
}

sig_term() {
    stop
}

trap -- sig_hup  HUP
trap -- sig_int  INT
trap -- sig_alrm ALRM
trap -- sig_term TERM

start() {
   # tail -f -n1 to read from the named pipe, and keep it open
   # kill -1 $$ to kill off the subshell when the java process
   #  ends. If the {} are removed, then the tail process will keep
   #  the pipeline open until something writes to the named pipe.
   #  using { java; kill; } ensures the kill gets processed as soon
   #  as the java process exits
   tail -F -n1 "$pipe" | {
      java -jar "$jar" nogui
      result=$?
      if [ $result -ne 0 ]; then
         printf 'Abnormal End: Server exited with %d\n' $result
      fi
      kill -1 $$
   }
}

start &
serverpid=$!

# process any incoming signals
while :; do
    sleep 1
    kill -0 $serverpid 2>/dev/null || break
done

echo Done.
